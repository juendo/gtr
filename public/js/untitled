// ARRAY DATA STRUCTURE
// optimised for indexing
class Array<E> {
	private E[] array = new E[100];

	// COMPLEXITY: O(1)
	public void get(int index) {
		return array[index];
	}

	// O(n)
	public void insert(E element, int index) {
		// for each element to the right of index
		for (int i = right; i > index; i++) {
			// shift it along one space
			array[i] = array[i - 1];
		}
		// then add in the new element
		array[i] = element;
	}

	// O(n)
	public void delete(E element, int index) {
		// for each element to the right of the index
		for (int i = index; i < right; i++) {
			// shift it one space to the left
			array[i] = array[i + 1];
		}
		// then remove the right-most element
		array[right] = null;
	}

	// O(n)
	public E linearSearch(E element) {
		// for each element in the array
		for (int i = 0; i < right; i++) {
			// compare equality
			if (array[i].equals(E)) {
				return array[i];
			}
		}
		return null;
	}

	// O(log2 n)
	public boolean binarySearch(E element) {
		// assume we have first and last index of array
		int mid = (first + last) / 2;
		while (first <= last) {
			switch (array[mid].compareTo(element)) {
				// return if eqal
				case 0:
				return array[mid];
				// case less than, must be in right half
				case -1:
				first = mid + 1;
				case 1:
				last = mid - 1;
			}
		}
		return null;
	}

	// O(n + m)
	public E[] merge(E[] b) {
		// create new array of combined length
		E[] c = new e[array.length + b.length];
		// track current positions within each
		// assume we have start and end indices of each
		int i = la, j = lb, k = lc;
		while (i <= ra && j <= rb) {
			if (array[i] <= b[j]) {
				c[k++] = array[i++];
			} else {
				c[k++] = b[j++];
			}
		}
		while (i <= ra) {
			c[k++] = array[i++];
		}
		while (j <= rb) {
			c[k++] = b[j++];
		}
		return c;
	}
}

// LINKED LIST DATA STRUCTURE
// optimised for insertion and deletion
class LinkedList<E> {
	// inner class for list nodes
	private static class Node<E> {
		private E element;
		private Node<E> succ;
		public Node(E element, Node<E> succ) {
			this.element = element;
			this.succ = succ;
		}
		public setSucc(Node<E> succ) {
			this.succ = succ;
		}
		public getSucc() {
			return succ;
		}
	}

	private Node<E> first;

	// O(1)
	public insertAfter(Node<E> pred, E elem) {
		Node<E> node = new Node<E>(elem, null);
		if (pred == null) {
			node.succ = first;
			first = node;
		} else {
			node.succ = pred.getSucc();
			pred.setSucc(node);
		}
	}
}

// can get singly linked lists and doubly linked lists

// ABSTRACT DATA TYPES ARE DEFINED IN TERMS OF BEHAVIOUR
// CONCRETE DATA STRUCTURES ARE DEFINED IN TERMS OF IMPLEMENTATION

// unbounded stack use SLL
// bounded stack use array
class BoundedStack<E> {
	private final int CAP = 100;
	private int size = 0;
	private E[] elements = new E[CAP];
	public void push(E element) {
		if (size < CAP) {
			elements[size++] == element;
		}
	}
	public E pop() {
		E out = null;
		if (size > 0) {
			out = elements[--size];
			elements[size] = null;
		}
		return out;
	}
	public E peek() {
		return (size > 0) ? elements[size] : null;
	}
	public void clear() {
		size = 0;
	}
	public boolean isEmpty() {
		return size == 0;
	}
}

class UnboundedStack<E> {
	private int depth = 0;
	private SinglyLinkedList<E> list = new SinglyLinkedList<E>();
	public void push(E element) {
		depth++;
		list.insertFirst(element);
	}
	public E pop() {
		depth--;
		return list.removeFirst();
	}
	public E peek() {
		return list.getFirst();
	}
	public void clear() {
		list = new SinglyLinkedList<E>();
		depth = 0;
	}
	public boolean isEmpty() {
		return depth == 0;
	}
}

// using modular arithmetic
class BoundedQueue<E> {
	private final int CAP = 100;
	private int size = 0;
	private final int front = 0;
	private final int rear = 0;
	private E[] elements = new E[CAP];
	public void clear() {
		size = 0;
		front = 0;
		rear = 0;
	}
	public boolean isEmpty() {
		return size == 0;
	}
	public int size() {
		return size();
	}
	public void addLast(E element) {
		// check if size is less than CAP
		elements[rear++] = element;
		rear == CAP ? rear = 0;
		size++;
	}
	public E getFirst() {
		return elements[front];
	}
	public E removeFirst() {
		// check if size is greater than zero
		E out = elements[front];
		elements[front++] = null;
		front == CAP ? front == 0;
		size--;
	}
}

class UnboundedQueue<E> {
	private static class Node<E> {
		private E element;
		private Node<E> next;
		public Node<E>(E element, Node<E> next) {
			this.element = element;
			this.next = next;
		}
		public E getElement() {
			return element;
		}
		public Node<E> getNext() {
			return next;
		}
		public void setNext(Node<E> next) {
			this.next = next;
		}
	}
	private Node<E> first;
	private Node<E> last;
	private int size;
	public void clear() {
		first = null;
		last = null;
		size = 0;
	}
	public boolean isEmpty() {
		return size == 0;
	}
	public int size() {
		return size;
	}
	public void addLast(E element) {
		Node<E> node = new Node<E>(element, null);
		if (isEmpty()) {
			first = node;
		} else {
			last.setNext(node);
		}
		last = node;
	}
	public E removeFirst() {
		if (isEmpty()) {
			return null;
		}
		E out = first.getElement();
		if (first == last) {
			last = null;
		}
		first = first.getNext();
	}
}